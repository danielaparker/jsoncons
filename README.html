<!DOCTYPE html>
<html>
<head>
<title>README</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1>jsoncons: a C++ library for json construction</h1>

<p>jsoncons is a C++ library for the construction of <a href="http://www.json.org">JavaScript Object Notation (JSON)</a>. It supports parsing a JSON file or string into a <code>json</code> value, building a <code>json</code> value in C++ code, and serializing a <code>json</code> value to a file or string. It also provides an API for generating json read and write events in code, somewhat analogously to SAX processing in the XML world. Consult the wiki for the latest <a href="https://github.com/danielaparker/jsoncons/wiki">documentation and tutorials</a> and <a href="https://github.com/danielaparker/jsoncons/wiki/Roadmap">roadmap</a>. </p>

<p>jsoncons uses some features that are new to C++ 11, particularly <a href="http://thbecker.net/articles/rvalue_references/section_02.html">move semantics</a> and the <a href="http://en.cppreference.com/w/cpp/concept/AllocatorAwareContainer">AllocatorAwareContainer</a> concept. Through the use of conditional directives, however, it retains compatibility with VC++ 10 SP1 (note that SP1 is required for VC++ 10, it fixes compiler bugs with move semantics.) It has been tested with MS Visual C++ 10 SP1, MS Visual C++ 15, clang 3.3 and GCC 4.8. </p>

<p>The <a href="https://github.com/danielaparker/jsoncons">code repository</a> and <a href="https://github.com/danielaparker/jsoncons/releases">releases</a> are on github. It is distributed under the <a href="http://www.boost.org/users/license.html">Boost Software License</a></p>

<p>The library has a number of features, which are listed below:</p>

<ul>
<li>Uses the standard C++ input/output streams library</li>
<li>Implements parsing and serializing JSON text in UTF-8 for narrow character strings and streams</li>
<li>Supports UTF16 (UTF32) encodings with size 2 (size 4) wide characters</li>
<li>Correctly handles surrogate pairs in \uXXXX escape sequences</li>
<li>Supports event based JSON parsing and serializing with user defined input and output handlers</li>
<li>Accepts and ignores single line comments that start with //, and multi line comments that start with /* and end with */</li>
<li>Supports optional escaping of the solidus (/) character</li>
<li>Supports Nan, Inf and -Inf replacement</li>
<li>Supports reading a sequence of JSON texts from a stream</li>
<li>Supports optional escaping of non-ascii UTF-8 octets</li>
<li>Allows extensions to the types accepted by the json class accessors and modifiers</li>
<li>Supports storing "any" values in a json object or array, with specialized serialization</li>
<li>Supports reading (writing) JSON values from (to) CSV files</li>
<li>Passes all tests from <a href="http://www.json.org/JSON_checker/">JSON_checker</a> except <code>fail1.json</code>, which is allowed in <a href="http://www.ietf.org/rfc/rfc7159.txt">RFC7159</a>
</li>
<li>Handles JSON texts of arbitrarily large depth of nesting, a limit can be set if desired</li>
<li>Supports <a href="http://goessner.net/articles/JsonPath/">Stefan Goessner's JsonPath</a>
</li>
</ul>

<p>As the <code>jsoncons</code> library has evolved, names have sometimes changed. To ease transition, jsoncons deprecates the old names but continues to support many of them. See the <a href="https://github.com/danielaparker/jsoncons/wiki/deprecated">deprecated list</a> for the status of old names. The deprecated names can be suppressed by defining macro JSONCONS_NO_DEPRECATED, which is recommended for new code.</p>

<p>What's new on master</p>

<ul>
<li><p>The first template parameter of <code>basic_json</code> has been changed from <code>CharT</code> (char or wchar_t) to StringT (std::string or std::wstring). This change will be transparent to anyone using <code>json</code> or <code>wjson</code>, but those using custom allocators will need to change this template parameter.</p></li>
<li><p>The first two template parameters of <code>json_type_traits</code>, <code>CharT</code> and <code>Alloc</code>, have been replaced with <code>JsonT</code>, the json class itself, rather than its template parameters. This change will be transparent to everyone except those who have extended <code>json_type_traits</code>, who will need to make this change.</p></li>
</ul>

<h2>Benchmarks</h2>

<p><a href="https://github.com/danielaparker/json_benchmarks">json_benchmarks</a> provides some measurements about how <code>jsoncons</code> compares to other <code>json</code> libraries.</p>

<h2>Using the jsoncons library</h2>

<p>The jsoncons library is header-only: it consists solely of header files containing templates and inline functions, and requires no separately-compiled library binaries when linking. It has no dependence on other libraries. The accompanying test suite uses boost, but not the library itself.</p>

<p>To install the jsoncons library, download the zip file, unpack the release, under <code>src</code> find the directory <code>jsoncons</code>, and copy it to your <code>include</code> directory. If you wish to use extensions, copy the <code>jsoncons_ext</code> directory as well. </p>

<p>For a quick guide, see the article <a href="http://danielaparker.github.io/jsoncons">jsoncons: a C++ library for json construction</a>.</p>

<h2>Building the test suite and examples with CMake</h2>

<p><a href="https://cmake.org/">CMake</a> is a C++ Makefiles/Solution generator for cross-platform software development. </p>

<p>Instructions for building the test suite with CMake may be found in</p>

<pre><code>jsoncons/test_suite/build/cmake/README.txt
</code></pre>

<p>Instructions for building the examples with CMake may be found in</p>

<pre><code>jsoncons/examples/build/cmake/README.txt
</code></pre>

<h2>Examples</h2>

<p>The examples below illustrate the use of the <a href="https://github.com/danielaparker/jsoncons/wiki/json">json</a> class and <a href="https://github.com/danielaparker/jsoncons/wiki/json_query">json_query</a> function.</p>

<h3>json construction</h3>

<div class="highlight highlight-source-c++"><pre>    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jsoncons/json.hpp<span class="pl-pds">"</span></span>

    <span class="pl-c">// For convenience</span>
    <span class="pl-k">using</span> jsoncons::json;

    <span class="pl-c">// Construct a book object</span>
    json book1;

    book1[<span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>] = <span class="pl-s"><span class="pl-pds">"</span>Fiction<span class="pl-pds">"</span></span>;
    book1[<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>] = <span class="pl-s"><span class="pl-pds">"</span>A Wild Sheep Chase: A Novel<span class="pl-pds">"</span></span>;
    book1[<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>] = <span class="pl-s"><span class="pl-pds">"</span>Haruki Murakami<span class="pl-pds">"</span></span>;
    book1[<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>] = <span class="pl-s"><span class="pl-pds">"</span>2002-04-09<span class="pl-pds">"</span></span>;
    book1[<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>] = <span class="pl-c1">9.01</span>;
    book1[<span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>] = <span class="pl-s"><span class="pl-pds">"</span>037571894X<span class="pl-pds">"</span></span>;  

    <span class="pl-c">// Construct another using the set function</span>
    json book2;

    book2.set(<span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>History<span class="pl-pds">"</span></span>);
    book2.set(<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Charlie Wilson's War<span class="pl-pds">"</span></span>);
    book2.set(<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>George Crile<span class="pl-pds">"</span></span>);
    book2.set(<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>2007-11-06<span class="pl-pds">"</span></span>);
    book2.set(<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>, <span class="pl-c1">10.50</span>);
    book2.set(<span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>0802143415<span class="pl-pds">"</span></span>);  

    <span class="pl-c">// Use set again, but more efficiently</span>
    json book3;

    <span class="pl-c">// Reserve memory, to avoid reallocations</span>
    book3.reserve(<span class="pl-c1">6</span>);

    <span class="pl-c">// Insert in name alphabetical order</span>
    <span class="pl-c">// Give set a hint where to insert the next member</span>
    json::object_iterator hint;
    hint = book3.set(book3.members().begin(),<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Haruki Murakami<span class="pl-pds">"</span></span>);
    hint = book3.set(hint, <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Fiction<span class="pl-pds">"</span></span>);
    hint = book3.set(hint, <span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>2006-01-03<span class="pl-pds">"</span></span>);
    hint = book3.set(hint, <span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>1400079276<span class="pl-pds">"</span></span>);  
    hint = book3.set(hint, <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>, <span class="pl-c1">13.45</span>);
    hint = book3.set(hint, <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Kafka on the Shore<span class="pl-pds">"</span></span>);

    <span class="pl-c">// Construct a fourth from a string</span>
    json book4 = json::parse(R<span class="pl-s"><span class="pl-pds">"</span>(</span>
<span class="pl-s">    {</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>category<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span>Fiction<span class="pl-s"><span class="pl-pds">"</span>,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>title<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span>Pulp<span class="pl-s"><span class="pl-pds">"</span>,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>author<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span>Charles Bukowski<span class="pl-s"><span class="pl-pds">"</span>,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>date<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span><span class="pl-c1">2004</span>-<span class="pl-c1">07</span>-<span class="pl-c1">08</span><span class="pl-s"><span class="pl-pds">"</span>,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>price<span class="pl-s"><span class="pl-pds">"</span> : 22.48,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>isbn<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span><span class="pl-c1">1852272007</span><span class="pl-s"><span class="pl-pds">"</span>  </span>
<span class="pl-s">    }</span>
<span class="pl-s">    )<span class="pl-pds">"</span></span>);

    <span class="pl-c">// Construct a booklist array</span>
    json booklist = json::array();

    <span class="pl-c">// For efficiency, reserve memory, to avoid reallocations</span>
    booklist.reserve(<span class="pl-c1">4</span>);

    <span class="pl-c">// For efficency, tell jsoncons to move the contents </span>
    <span class="pl-c">// of the four book objects into the array</span>
    booklist.add(std::move(book1));    
    booklist.add(std::move(book2));    

    <span class="pl-c">// Add the third book to the front</span>
    <span class="pl-k">auto</span> pos = booklist.add(booklist.elements().begin(),std::move(book3));

    <span class="pl-c">// and the last one immediately after</span>
    booklist.add(pos+<span class="pl-c1">1</span>,std::move(book4));    

    <span class="pl-c">// See what's left of book1, 2, 3 and 4 (expect nulls)</span>
    std::cout &lt;&lt; book1 &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> &lt;&lt; book2 &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> &lt;&lt; book3 &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> &lt;&lt; book4 &lt;&lt; std::endl;</pre></div>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-c">//Loop through the booklist elements using a range-based for loop    </span>
    <span class="pl-k">for</span> (<span class="pl-k">auto</span> book : booklist.elements())
    {
        std::cout &lt;&lt; book[<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::string&gt;()
                  &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>
                  &lt;&lt; book[<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;<span class="pl-k">double</span>&gt;() &lt;&lt; std::endl;
    }

    <span class="pl-c">// The second book</span>
    json&amp; book = booklist[<span class="pl-c1">1</span>];

    <span class="pl-c">//Loop through the book's name-value pairs using a range-based for loop    </span>
    <span class="pl-k">for</span> (<span class="pl-k">auto</span> member : book.members())
    {
        std::cout &lt;&lt; member.<span class="pl-c1">name</span>()
                  &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>
                  &lt;&lt; member.<span class="pl-c1">value</span>() &lt;&lt; std::endl;
    }

    <span class="pl-k">auto</span> it = book.find(<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>);
    <span class="pl-k">if</span> (it != book.members().end())
    {
        <span class="pl-c">// member "author" found</span>
    }

    <span class="pl-k">if</span> (book.count(<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>) &gt; <span class="pl-c1">0</span>)
    {
        <span class="pl-c">// book has a member "author"</span>
    }

    book.get(<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>author unknown<span class="pl-pds">"</span></span>).as&lt;std::string&gt;();
    <span class="pl-c">// Returns author if found, otherwise "author unknown"</span>

    <span class="pl-k">try</span>
    {
        book[<span class="pl-s"><span class="pl-pds">"</span>ratings<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::string&gt;();
    }
    <span class="pl-k">catch</span> (<span class="pl-k">const</span> std::out_of_range&amp; e)
    {
        <span class="pl-c">// member "ratings" not found</span>
    }

    <span class="pl-c">// Add ratings</span>
    book[<span class="pl-s"><span class="pl-pds">"</span>ratings<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>*****<span class="pl-pds">"</span></span>] = <span class="pl-c1">4</span>;
    book[<span class="pl-s"><span class="pl-pds">"</span>ratings<span class="pl-pds">"</span></span>][<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>] = <span class="pl-c1">2</span>;

    <span class="pl-c">// Delete one-star ratings</span>
    book[<span class="pl-s"><span class="pl-pds">"</span>ratings<span class="pl-pds">"</span></span>].erase(<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>);
</pre></div>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-c">// Serialize the booklist to a file</span>
    std::ofstream <span class="pl-en">os</span>(<span class="pl-s"><span class="pl-pds">"</span>booklist.json<span class="pl-pds">"</span></span>);
    os &lt;&lt; pretty_print(booklist);</pre></div>

<p>The JSON output <code>booklist.json</code></p>

<div class="highlight highlight-source-json"><pre>    [
        {
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Haruki Murakami<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Fiction<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>2006-01-03<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>1400079276<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>:<span class="pl-c1">13.45</span>,
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Kafka on the Shore<span class="pl-pds">"</span></span>
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Charles Bukowski<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Fiction<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>2004-07-08<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>1852272007<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>:<span class="pl-c1">22.48</span>,
            <span class="pl-s"><span class="pl-pds">"</span>ratings<span class="pl-pds">"</span></span>:
            {
                <span class="pl-s"><span class="pl-pds">"</span>*****<span class="pl-pds">"</span></span>:<span class="pl-c1">4</span>
            },
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Pulp<span class="pl-pds">"</span></span>
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Haruki Murakami<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Fiction<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>2002-04-09<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>037571894X<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>:<span class="pl-c1">9.01</span>,
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>A Wild Sheep Chase: A Novel<span class="pl-pds">"</span></span>
        },
        {
            <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>George Crile<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>History<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>2007-11-06<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>0802143415<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>:<span class="pl-c1">10.5</span>,
            <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>Charlie Wilson's War<span class="pl-pds">"</span></span>
        }
    ]</pre></div>

<h3>json query</h3>

<div class="highlight highlight-source-c++"><pre>    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>fstream<span class="pl-pds">&gt;</span></span>
    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jsoncons/json.hpp<span class="pl-pds">"</span></span>
    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jsoncons_ext/jsonpath/json_query.hpp<span class="pl-pds">"</span></span>

    <span class="pl-c">// For convenience</span>
    <span class="pl-k">using</span> jsoncons::json;
    <span class="pl-k">using</span> jsoncons::jsonpath::json_query;

    <span class="pl-c">// Deserialize the booklist</span>
    std::ifstream <span class="pl-en">is</span>(<span class="pl-s"><span class="pl-pds">"</span>booklist.json<span class="pl-pds">"</span></span>);
    json booklist;
    is &gt;&gt; booklist;

    <span class="pl-c">// Use a JsonPath expression to find </span>
    <span class="pl-c">//  </span>
    <span class="pl-c">// (1) The authors of books that cost less than $12</span>
    json result = json_query(booklist, <span class="pl-s"><span class="pl-pds">"</span>$[*][?(@.price &lt; 12)].author<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>(1) <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;

    <span class="pl-c">// (2) The number of books</span>
    result = json_query(booklist, <span class="pl-s"><span class="pl-pds">"</span>$.length<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>(2) <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;

    <span class="pl-c">// (3) The third book</span>
    result = json_query(booklist, <span class="pl-s"><span class="pl-pds">"</span>$[2]<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>(3) <span class="pl-pds">"</span></span> &lt;&lt; std::endl &lt;&lt; pretty_print(result) &lt;&lt; std::endl;

    <span class="pl-c">// (4) The authors of books that were published in 2004</span>
    result = json_query(booklist, <span class="pl-s"><span class="pl-pds">"</span>$[*][?(@.date =~ /2004.*?/)].author<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>(4) <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;

    <span class="pl-c">// (5) The titles of all books that have ratings</span>
    result = json_query(booklist, <span class="pl-s"><span class="pl-pds">"</span>$[*][?(@.ratings)].title<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>(5) <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;</pre></div>

<p>Result:</p>

<pre><code>    (1) ["Haruki Murakami","George Crile"]
    (2) [4]
    (3)
    [
        {
            "author":"Haruki Murakami",
            "category":"Fiction",
            "date":"2002-04-09",
            "isbn":"037571894X",
            "price":9.01,
            "title":"A Wild Sheep Chase: A Novel"
        }
    ]
    (4) ["Charles Bukowski"]
    (5) ["Pulp"]
</code></pre>

<h2>Once again, this time with wide characters</h2>

<h3>wjson construction</h3>

<div class="highlight highlight-source-c++"><pre>    #<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>jsoncons/json.hpp<span class="pl-pds">"</span></span>

    <span class="pl-c">// For convenience</span>
    <span class="pl-k">using</span> jsoncons::wjson;

    <span class="pl-c">// Construct a book object</span>
    wjson book1;

    book1[L<span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>] = L<span class="pl-s"><span class="pl-pds">"</span>Fiction<span class="pl-pds">"</span></span>;
    book1[L<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>] = L<span class="pl-s"><span class="pl-pds">"</span>A Wild Sheep Chase: A Novel<span class="pl-pds">"</span></span>;
    book1[L<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>] = L<span class="pl-s"><span class="pl-pds">"</span>Haruki Murakami<span class="pl-pds">"</span></span>;
    book1[L<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>] = L<span class="pl-s"><span class="pl-pds">"</span>2002-04-09<span class="pl-pds">"</span></span>;
    book1[L<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>] = <span class="pl-c1">9.01</span>;
    book1[L<span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>] = L<span class="pl-s"><span class="pl-pds">"</span>037571894X<span class="pl-pds">"</span></span>;

    <span class="pl-c">// Construct another using the set function</span>
    wjson book2;

    book2.set(L<span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>History<span class="pl-pds">"</span></span>);
    book2.set(L<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>Charlie Wilson's War<span class="pl-pds">"</span></span>);
    book2.set(L<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>George Crile<span class="pl-pds">"</span></span>);
    book2.set(L<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>2007-11-06<span class="pl-pds">"</span></span>);
    book2.set(L<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>, <span class="pl-c1">10.50</span>);
    book2.set(L<span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>0802143415<span class="pl-pds">"</span></span>);

    <span class="pl-c">// Use set again, but more efficiently</span>
    wjson book3;

    <span class="pl-c">// Reserve memory, to avoid reallocations</span>
    book3.reserve(<span class="pl-c1">6</span>);

    <span class="pl-c">// Insert in name alphabetical order</span>
    <span class="pl-c">// Give set a hint where to insert the next member</span>
    wjson::object_iterator hint;
    hint = book3.set(book3.members().begin(), L<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>Haruki Murakami<span class="pl-pds">"</span></span>);
    hint = book3.set(hint, L<span class="pl-s"><span class="pl-pds">"</span>category<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>Fiction<span class="pl-pds">"</span></span>);
    hint = book3.set(hint, L<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>2006-01-03<span class="pl-pds">"</span></span>);
    hint = book3.set(hint, L<span class="pl-s"><span class="pl-pds">"</span>isbn<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>1400079276<span class="pl-pds">"</span></span>);
    hint = book3.set(hint, L<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>, <span class="pl-c1">13.45</span>);
    hint = book3.set(hint, L<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>Kafka on the Shore<span class="pl-pds">"</span></span>);

    <span class="pl-c">// Construct a fourth from a string</span>
    wjson book4 = wjson::parse(LR<span class="pl-s"><span class="pl-pds">"</span>(</span>
<span class="pl-s">    {</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>category<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span>Fiction<span class="pl-s"><span class="pl-pds">"</span>,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>title<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span>Pulp<span class="pl-s"><span class="pl-pds">"</span>,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>author<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span>Charles Bukowski<span class="pl-s"><span class="pl-pds">"</span>,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>date<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span><span class="pl-c1">2004</span>-<span class="pl-c1">07</span>-<span class="pl-c1">08</span><span class="pl-s"><span class="pl-pds">"</span>,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>price<span class="pl-s"><span class="pl-pds">"</span> : 22.48,</span>
<span class="pl-s">        <span class="pl-pds">"</span></span>isbn<span class="pl-s"><span class="pl-pds">"</span> : <span class="pl-pds">"</span></span><span class="pl-c1">1852272007</span><span class="pl-s"><span class="pl-pds">"</span>  </span>
<span class="pl-s">    }</span>
<span class="pl-s">    )<span class="pl-pds">"</span></span>);

    <span class="pl-c">// Construct a booklist array</span>
    wjson booklist = wjson::array();

    <span class="pl-c">// For efficiency, reserve memory, to avoid reallocations</span>
    booklist.reserve(<span class="pl-c1">4</span>);

    <span class="pl-c">// For efficency, tell jsoncons to move the contents </span>
    <span class="pl-c">// of the four book objects into the array</span>
    booklist.add(std::move(book1));
    booklist.add(std::move(book2));

    <span class="pl-c">// Add the third book to the front</span>
    <span class="pl-k">auto</span> pos = booklist.add(booklist.elements().begin(),std::move(book3));

    <span class="pl-c">// and the last one immediately after</span>
    booklist.add(pos+<span class="pl-c1">1</span>,std::move(book4));    

    <span class="pl-c">// See what's left of book1, 2, 3 and 4 (expect nulls)</span>
    std::wcout &lt;&lt; book1 &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> &lt;&lt; book2 &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> &lt;&lt; book3 &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> &lt;&lt; book4 &lt;&lt; std::endl;</pre></div>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-c">//Loop through the booklist elements using a range-based for loop    </span>
    <span class="pl-k">for</span> (<span class="pl-k">auto</span> book : booklist.elements())
    {
        std::wcout &lt;&lt; book[L<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::wstring&gt;()
                   &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>
                   &lt;&lt; book[L<span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;<span class="pl-k">double</span>&gt;() &lt;&lt; std::endl;
    }

    <span class="pl-c">// The second book</span>
    wjson&amp; book = booklist[<span class="pl-c1">1</span>];

    <span class="pl-c">//Loop through the book's name-value pairs using a range-based for loop    </span>
    <span class="pl-k">for</span> (<span class="pl-k">auto</span> member : book.members())
    {
        std::wcout &lt;&lt; member.<span class="pl-c1">name</span>()
                   &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>
                   &lt;&lt; member.<span class="pl-c1">value</span>() &lt;&lt; std::endl;
    }

    <span class="pl-k">auto</span> it = book.find(L<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>);
    <span class="pl-k">if</span> (it != book.members().end())
    {
        <span class="pl-c">// member "author" found</span>
    }

    <span class="pl-k">if</span> (book.count(L<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>) &gt; <span class="pl-c1">0</span>)
    {
        <span class="pl-c">// book has a member "author"</span>
    }

    book.get(L<span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>, L<span class="pl-s"><span class="pl-pds">"</span>author unknown<span class="pl-pds">"</span></span>).as&lt;std::wstring&gt;();
    <span class="pl-c">// Returns author if found, otherwise "author unknown"</span>

    <span class="pl-k">try</span>
    {
        book[L<span class="pl-s"><span class="pl-pds">"</span>ratings<span class="pl-pds">"</span></span>].<span class="pl-smi">as</span>&lt;std::wstring&gt;();
    }
    <span class="pl-k">catch</span> (<span class="pl-k">const</span> std::out_of_range&amp; e)
    {
        <span class="pl-c">// member "ratings" not found</span>
    }

    <span class="pl-c">// Add ratings</span>
    book[L<span class="pl-s"><span class="pl-pds">"</span>ratings<span class="pl-pds">"</span></span>][L<span class="pl-s"><span class="pl-pds">"</span>*****<span class="pl-pds">"</span></span>] = <span class="pl-c1">4</span>;
    book[L<span class="pl-s"><span class="pl-pds">"</span>ratings<span class="pl-pds">"</span></span>][L<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>] = <span class="pl-c1">2</span>;

    <span class="pl-c">// Delete one-star ratings</span>
    book[L<span class="pl-s"><span class="pl-pds">"</span>ratings<span class="pl-pds">"</span></span>].erase(L<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>);
</pre></div>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-c">// Serialize the booklist to a file</span>
    std::wofstream <span class="pl-en">os</span>(L<span class="pl-s"><span class="pl-pds">"</span>booklist2.json<span class="pl-pds">"</span></span>);
    os &lt;&lt; pretty_print(booklist);</pre></div>

<h3>wjson query</h3>

<div class="highlight highlight-source-c++"><pre>    <span class="pl-c">// Deserialize the booklist</span>
    std::wifstream <span class="pl-en">is</span>(<span class="pl-s"><span class="pl-pds">"</span>booklist2.json<span class="pl-pds">"</span></span>);
    wjson booklist;
    is &gt;&gt; booklist;

    <span class="pl-c">// Use a JsonPath expression to find </span>
    <span class="pl-c">//  </span>
    <span class="pl-c">// (1) The authors of books that cost less than $12</span>
    wjson result = json_query(booklist, L<span class="pl-s"><span class="pl-pds">"</span>$[*][?(@.price &lt; 12)].author<span class="pl-pds">"</span></span>);
    std::wcout &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>(1) <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;

    <span class="pl-c">// (2) The number of books</span>
    result = json_query(booklist, L<span class="pl-s"><span class="pl-pds">"</span>$.length<span class="pl-pds">"</span></span>);
    std::wcout &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>(2) <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;

    <span class="pl-c">// (3) The third book</span>
    result = json_query(booklist, L<span class="pl-s"><span class="pl-pds">"</span>$[2]<span class="pl-pds">"</span></span>);
    std::wcout &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>(3) <span class="pl-pds">"</span></span> &lt;&lt; std::endl &lt;&lt; pretty_print(result) &lt;&lt; std::endl;

    <span class="pl-c">// (4) The authors of books that were published in 2004</span>
    result = json_query(booklist, L<span class="pl-s"><span class="pl-pds">"</span>$[*][?(@.date =~ /2004.*?/)].author<span class="pl-pds">"</span></span>);
    std::wcout &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>(4) <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;

    <span class="pl-c">// (5) The titles of all books that have ratings</span>
    result = json_query(booklist, L<span class="pl-s"><span class="pl-pds">"</span>$[*][?(@.ratings)].title<span class="pl-pds">"</span></span>);
    std::wcout &lt;&lt; L<span class="pl-s"><span class="pl-pds">"</span>(5) <span class="pl-pds">"</span></span> &lt;&lt; result &lt;&lt; std::endl;</pre></div>

<p>Result:</p>

<pre><code>    (1) ["Haruki Murakami","George Crile"]
    (2) [4]
    (3)
    [
        {
            "author":"Haruki Murakami",
            "category":"Fiction",
            "date":"2002-04-09",
            "isbn":"037571894X",
            "price":9.01,
            "title":"A Wild Sheep Chase: A Novel"
        }
    ]
    (4) ["Charles Bukowski"]
    (5) ["Pulp"]
</code></pre>

<h2>Acknowledgements</h2>

<p>Special thanks to our <a href="https://github.com/danielaparker/jsoncons/blob/master/acknowledgements.txt">contributors</a></p>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
