<!DOCTYPE html>
<html>
<head>
<title>README</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1>jsoncons: a C++ library for json construction</h1>

<p>jsoncons is a C++ library for the construction of <a href="http://www.json.org">JavaScript Object Notation (JSON)</a>. It supports parsing a JSON file or string into a tree structured <code>json</code> value, building a <code>json</code> value in C++ code, and serializing a <code>json</code> value to a file or string. It also provides an event-based API for reading and writing JSON documents that are too large to fit into available memory, somewhat analogously to SAX processing in the XML world. Consult the wiki for the latest <a href="https://github.com/danielaparker/jsoncons/wiki">documentation and tutorials</a> and <a href="https://github.com/danielaparker/jsoncons/wiki/Roadmap">roadmap</a>. </p>

<p>jsoncons uses some features that are new to C++ 11, particularly move semantics, however, it has been written to be compatible with VC++ 10 SP1 (note that SP1 is required for VC++ 10, it fixes compiler bugs with move semantics.) It has been tested with MS Visual C++ 10 SP1, Intel C++ Studio XE 2013, clang 3.3 and GCC 4.8. </p>

<p>The <a href="https://github.com/danielaparker/jsoncons">code repository</a> and <a href="https://github.com/danielaparker/jsoncons/releases">releases</a> are on github. It is distributed under the <a href="http://www.boost.org/users/license.html">Boost Software License</a></p>

<p>The library has a number of features, which are listed below:</p>

<ul class="task-list">
<li>Uses the standard C++ input/output streams library</li>
<li>Implements parsing and serializing JSON text in UTF-8 for narrow character strings and streams</li>
<li>Supports UTF16 (UTF32) encodings with size 2 (size 4) wide characters</li>
<li>Correctly handles surrogate pairs in \uXXXX escape sequences</li>
<li>Supports event based JSON parsing and serializing with user defined input and output handlers</li>
<li>Guarantees basic exception safety (no leaks)</li>
<li>Accepts and ignores single line comments that start with //, and multi line comments that start with /* and end with */</li>
<li>Supports optional escaping of the solidus (/) character</li>
<li>Supports Nan, Inf and -Inf replacement</li>
<li>Supports reading multiple json objects from a stream</li>
<li>Supports optional escaping of non-ascii UTF-8 octets</li>
<li>Allows extensions to the types accepted by the json class accessors and modifiers</li>
<li>Supports storing "any" values in a json object or array, with specialized serialization</li>
<li>Supports reading (writing) JSON values from (to) CSV files</li>
</ul>

<h2>What's new in Release 0.97.1</h2>

<ul class="task-list">
<li>"Transforming JSON with filters" example fixed</li>
<li>Added a class-specific in-place new to the json class that is implemented in terms of the global version (required to create json objects with placement new operator.)</li>
<li>Reorganized header files, removing unnecessary includes. </li>
<li>Incorporates validation contributed by Alex Merry for ensuring that there is an object or array on parse head.</li>
<li>Incorporates fix contributed by Milan Burda for “Switch case is in protected scope” clang build error</li>
</ul>

<h2>Using the code</h2>

<p>The jsoncons library is header-only: it consists solely of header files containing templates and inline functions, and requires no separately-compiled library binaries when linking. It has no dependence on other libraries. The accompanying test suite uses boost, but not the library itself.</p>

<p>To install the jsoncons library, download the zip file, unpack the release, under <code>src</code> find the directory <code>jsoncons</code>, and copy it to your <code>include</code> directory. If you wish to use extensions, copy the <code>jsoncons_ext</code> directory as well. </p>

<p>The jsoncons classes and functions are in namespace <code>jsoncons</code>.  Namespace <code>jsoncons</code> includes a name for a null type defined as an empty struct:</p>

<pre><code>struct null_type{}
</code></pre>

<p>The following using declarations are for the examples that appear below.</p>

<pre><code>#include "jsoncons/json.hpp"

using std::string;
using std::cout;
using std::endl;
using jsoncons::json;
using jsoncons::pretty_print;
</code></pre>

<h3>Reading json values from a file</h3>

<p>Here is a sample file (books.json):</p>

<pre><code>[
    {
        "title" : "Kafka on the Shore",
        "author" : "Haruki Murakami",
        "price" : 25.17
    },
    {
        "title" : "Women: A Novel",
        "author" : "Charles Bukowski",
        "price" : 12.00
    },
    {
        "title" : "Cutter's Way",
        "author" : "Ivan Passer"
    }
]
</code></pre>

<p>You can read the file into a json value like this</p>

<pre><code>json books = json::parse_file("books.json");
</code></pre>

<p>You can then loop through the books</p>

<pre><code>for (size_t i = 0; i &lt; books.size(); ++i)
{
    try
    {
        json&amp; book = books[i];
        string author = book["author"].as&lt;string&gt;();
        string title = book["title"].as&lt;string&gt;();
        double price = book["price"].as&lt;double&gt;();
        cout &lt;&lt; author &lt;&lt; ", " &lt;&lt; title &lt;&lt; ", " &lt;&lt; price &lt;&lt; endl;
    }
    catch (const json_exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
    }
}
</code></pre>

<p>The output is</p>

<pre><code>Haruki Murakami, Kafka on the Shore, 25.17
Charles Bukowski, Women: A Novel, 12
Member price not found.
</code></pre>

<p>Note that the third book is missing a price, which causes an exception to be thrown.</p>

<p>You have a choice of accessors:</p>

<pre><code>book["price"] will throw if there is no price
book.get("price") will return json::null if there is no price
book.get("price",default_value) will return default_value if there is no price
</code></pre>

<p>So if you want to show "n/a" for the missing price, you can use this accessor</p>

<pre><code>string price = book.get("price","n/a").as&lt;string&gt;();
</code></pre>

<p>and the output becomes</p>

<pre><code>Haruki Murakami, Kafka on the Shore, 25.17
Charles Bukowski, Women: A Novel, 12.0
Ivan Passer, Cutter's Way, n/a
</code></pre>

<p>Or you can check if book has a member "price" with the method <code>has_member</code>, and output accordingly,</p>

<pre><code>if (book.has_member("price"))
{
    double price = book["price"].as&lt;double&gt;();
    cout &lt;&lt; price;
}
else
{
    cout &lt;&lt; "n/a";
}
</code></pre>

<h3>Constructing json values in C++</h3>

<p>To construct an empty json object, use the default constructor:</p>

<pre><code> json image_sizing;
</code></pre>

<p>Serializing it to standard out</p>

<pre><code>cout &lt;&lt; image_sizing &lt;&lt; endl;
</code></pre>

<p>produces</p>

<pre><code>{}
</code></pre>

<p>Adding some members,</p>

<pre><code>image_sizing["resize_to_fit"] = true;  // a boolean 
image_sizing["resize_unit"] =  "pixels";  // a string
image_sizing["resize_what"] =  "long_edge";  // a string
image_sizing["dimension1"] = 9.84;  // a double
image_sizing["dimension2"] = json::null;  // a null
</code></pre>

<p>Serializing it, this time with pretty print,</p>

<pre><code>cout &lt;&lt; pretty_print(image_sizing) &lt;&lt; endl;
</code></pre>

<p>produces</p>

<pre><code>{
    "dimension1":9.84,
    "dimension2":null,
    "resize_to_fit":true,
    "resize_unit":"pixels",
    "resize_what":"long_edge"
}
</code></pre>

<p>To construct a json array, use the copy constructor with a prototype json array:</p>

<pre><code>json image_formats(json::an_array);
</code></pre>

<p>Adding some elements,</p>

<pre><code>image_formats.add("JPEG");
image_formats.add("PSD");
image_formats.add("TIFF");
image_formats.add("DNG");
</code></pre>

<p>Combining the two</p>

<pre><code>json file_export;
file_export["image_formats"] = std::move(image_formats);
file_export["image_sizing"] = std::move(image_sizing);
</code></pre>

<p>and serializing</p>

<pre><code>cout &lt;&lt; pretty_print(file_export) &lt;&lt; endl;
</code></pre>

<p>produces</p>

<pre><code>{
    "image_formats":
    ["JPEG","PSD","TIFF","DNG"],
    "image_sizing":
    {
        "dimension1":9.84,
        "dimension2":null,
        "resize_to_fit":true,
        "resize_unit":"pixels",
        "resize_what":"long_edge"
    }
}
</code></pre>

<h3>Iterators</h3>

<p><code>jsoncons::json</code> supports iterators for accessing the members of json objects and the elements of json arrays.</p>

<p>An example of iterating over the name-value pairs of a json object:</p>

<pre><code>json person;
person["first_name"] = "Jane";
person["last_name"] = "Roe";
person["events_attended"] = 10;
person["accept_waiver_of_liability"] = true;

for (auto it = person.begin_members(); it != person.end_members(); ++it)
{
    cout &lt;&lt; "name=" &lt;&lt; it-&gt;name() &lt;&lt; ", value=" &lt;&lt; it-&gt;value().as&lt;string&gt;() &lt;&lt; endl;
}
</code></pre>

<p>An example of iterating over the elements of a json array:</p>

<pre><code>json cities(json::an_array);
cities.add("Montreal");
cities.add("Toronto");
cities.add("Ottawa");
cities.add("Vancouver");

for (auto it = cities.begin_elements(); it != cities.end_elements(); ++it)
{
    cout &lt;&lt; it-&gt;as&lt;string&gt;() &lt;&lt; endl;
}
</code></pre>

<h2>About jsoncons::json</h2>

<p>The json class is an instantiation of the <code>basic_json</code> class template that uses <code>char</code> as the character type<br>
and <code>std::allocator&lt;void&gt;</code> as the allocator type,</p>

<pre><code>typedef basic_json&lt;char,std::allocator&lt;void&gt;&gt; json
</code></pre>

<p>The library includes an instantiation for wide characters as well,</p>

<pre><code>typedef basic_json&lt;wchar_t,std::allocator&lt;void&gt;&gt; wjson
</code></pre>

<p>Note that the allocator type allows you to supply a custom allocator for dynamically allocated, <br>
fixed size small objects in the json container, the container rebinds it as necessay. <br>
For instance, you can use the boost <code>fast_pool_allocator</code>:</p>

<pre><code>#include &lt;boost/pool/pool_alloc.hpp&gt;
#include "jsoncons/json.hpp"

typedef jsoncons::basic_json&lt;char, boost::fast_pool_allocator&lt;void&gt;&gt; myjson;

myjson o;

o.set("FirstName","Joe");
o.set("LastName","Smith");
</code></pre>

<p>This results in a json object instance being allocated from the boost memory pool. <br>
The allocator type is not used for structures including vectors and strings that use large or variable amounts of memory, <br>
these always use the default allocators.</p>

<h2>Wide character support</h2>

<p>jsoncons supports wide character strings and streams with <code>wjson</code> and <code>wjson_reader</code>. It supports <code>UTF16</code> encoding if <code>wchar_t</code> has size 2 (Windows) and <code>UTF32</code> encoding if <code>wchar_t</code> has size 4. You can construct a <code>wjson</code> value in exactly the same way as a <code>json</code> value, for instance:</p>

<pre><code>using jsoncons::wjson;

wjson root;
root[L"field1"] = L"test";
root[L"field2"] = 3.9;
root[L"field3"] = true;

std::wcout &lt;&lt; root &lt;&lt; L"\n";
</code></pre>

<p>which prints</p>

<pre><code>{"field1":"test","field2":3.9,"field3":true}
</code></pre>

<h2>Type extensibility</h2>

<p>In the json class, accessors and modifiers are templated, for example,</p>

<pre><code>template&lt;typename T&gt;
bool is() const

template&lt;typename T&gt;
T as() const

template &lt;typename T&gt;
basic_json&amp; operator=(T val)
</code></pre>

<p>The implementations of these functions and operators make use of the class template <code>json_type_traits</code></p>

<pre><code>template &lt;typename Char, typename Alloc, typename T&gt;
class json_type_traits
{
public:
    bool is(const basic_json&amp; val) const {return false;}
    T as(const basic_json&amp; val) const;
    void assign(basic_json&amp; self, const T val);
};
</code></pre>

<p>This class template is extensible, you as a user can extend <code>json_type_traits</code> in the <code>jsoncons</code> namespace with your own types. You can, for example, extend <code>json_type_traits</code> to access and modify <code>json</code> structures with <code>boost::gregorian::date values</code>, and in your code, write</p>

<pre><code>json deal;
deal["maturity"] = boost::gregorian::date(2015,1,1);

json observation_dates(json::an_array);
observation_dates.add(boost::gregorian::date(2013,10,21));
observation_dates.add(boost::gregorian::date(2013,10,28));
deal["observation_dates"] = std::move(observation_dates);

boost::gregorian::date maturity = deal["maturity"].as&lt;boost::gregorian::date&gt;();

cout &lt;&lt; deal &lt;&lt; endl;   
</code></pre>

<p>producing</p>

<pre><code>{
    "maturity":"2015-01-01",
    "observation_dates":
    ["2013-10-21","2013-10-28"]
}
</code></pre>

<h2>json any</h2>

<p>jsoncons provides a class <code>json::any</code> that can contain a value of <br>
any type as long as that type supports copy construction and <br>
assignment. This allows you to, for example, insert a boost matrix into a <code>json</code> object, <br>
and to retrieve it back cast to the appropriate type. You can do so by wrapping it in<br>
a <code>json::any value</code>, like this:</p>

<pre><code>#include "jsoncons/json.hpp"
#include &lt;boost/numeric/ublas/matrix.hpp&gt;

using jsoncons::json;
using boost::numeric::ublas::matrix;

json obj;

matrix&lt;double&gt; A(2,2);
A(0,0) = 1;
A(0,1) = 2;
A(1,0) = 3;
A(1,1) = 4;

obj.set("mydata",json::any(A));

matrix&lt;double&gt;&amp; B = obj["mydata"].any_cast&lt;matrix&lt;double&gt;&gt;();
</code></pre>

<h3>Acknowledgements</h3>

<p>Special thanks to our <a href="https://github.com/danielaparker/jsoncons/blob/master/acknowledgements.txt">contributors</a></p>
</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
