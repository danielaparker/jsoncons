{
  "name": "jsoncons",
  "tagline": "C++ library for parsing and serializing JSON text",
  "body": "```c++\r\njsoncons::json\r\n\r\ntypedef basic_json<char,\r\n                   JsonTraits = json_traits<char>,\r\n                   Allocator = std::allocator<char>> json\r\n```\r\nThe `json` class is an instantiation of the `basic_json` class template that uses `char` as the character type. The order of an object's name/value pairs is not preserved, they are sorted alphabetically by name. If you want to preserve the original insertion order, use [ojson](ojson) instead.\r\n\r\nThe `jsoncons` library will always rebind the supplied allocator from the template parameter to internal data structures.\r\n\r\n### Header\r\n```c++\r\n#include <jsoncons/json.hpp>\r\n```\r\n\r\n### Member types\r\n\r\nMember type                         |Definition\r\n------------------------------------|------------------------------\r\n`json_type`|json type\r\n`allocator_type`|Allocator type\r\n`char_allocator`|String allocator type\r\n`array_allocator`|Array allocator type\r\n`object_allocator`|Object allocator \r\n`string_type`|Default `string_type` is `std::string`\r\n`string_view_type`|A non-owning view of a string, holds a pointer to character data and length. Supports conversion to and from strings. Will be typedefed to the C++ 17 `std:string_view` if `JSONCONS_HAS_STRING_VIEW` is defined in `jsoncons_config.hpp`, otherwise to a substitute.  \r\n`kvp_type `|[kvp_type ](kvp_type ) is a class that stores a name and a json value\r\n`null_type`|An alias for `jsoncons::null_type`\r\n`object`|json object type\r\n`array`|json array type\r\n`object_iterator`|A [RandomAccessIterator](http://en.cppreference.com/w/cpp/concept/RandomAccessIterator) to [kvp_type ](kvp_type )\r\n`const_object_iterator`|A const [RandomAccessIterator](http://en.cppreference.com/w/cpp/concept/RandomAccessIterator) to const [kvp_type ](kvp_type )\r\n`array_iterator`|A [RandomAccessIterator](http://en.cppreference.com/w/cpp/concept/RandomAccessIterator) to `json`\r\n`const_array_iterator`|A const [RandomAccessIterator](http://en.cppreference.com/w/cpp/concept/RandomAccessIterator) to `const json`\r\n\r\n### Static member functions\r\n\r\n    static json parse(string_view_type s)\r\n    static json parse(string_view_type s, \r\n                      parse_error_handler& err_handler)\r\nParses a string of JSON text and returns a json object or array value. \r\nThrows [parse_exception](parse_exception) if parsing fails.\r\n\r\n    static json parse_stream(std::istream& is)\r\n    static json parse_stream(std::istream& is, \r\n                             parse_error_handler& err_handler)\r\nParses an input stream of JSON text and returns a json object or array value. \r\nThrows [parse_exception](parse_exception) if parsing fails.\r\n\r\n    static json parse_file(const string_type& filename)\r\n    static json parse_file(const string_type& filename, \r\n                           parse_error_handler& err_handler)\r\nOpens a binary input stream to a JSON unicode file, parsing the file assuming UTF-8, and returns a json object or array value. This method expects that the file contains UTF-8 (or clean 7 bit ASCII), if that is not the case, use the `parse` method that takes an `std::istream` instead, imbue your stream with the appropriate facet for handling unicode conversions.\r\nThrows [parse_exception](parse_exception) if parsing fails.\r\n```c++\r\ntemplate <class T>\r\nstatic json make_array(size_ n, const T& val)\r\n\r\ntemplate <class T>\r\nstatic json make_array(size_ n, const T& val, \r\n                       const allocator_type& alloc = allocator_type())\r\n\r\ntemplate <size_t N>\r\nstatic json make_array(size_t size1 ... size_t sizeN)\r\n\r\ntemplate <size_t N,typename T>\r\nstatic json make_array(size_t size1 ... size_t sizeN, const T& val)\r\n\r\ntemplate <size_t N,typename T>\r\nstatic json make_array(size_t size1 ... size_t sizeN, const T& val, \r\n                       const allocator_type& alloc)\r\n```\r\nMakes a multidimensional array with the number of dimensions specified as a template parameter. The size of each dimension is passed as a parameter, and optionally an inital value. If no initial value, the default is an empty json object. The elements may be accessed using familiar C++ native array syntax.\r\n\r\n    static const json& null()\r\nReturns a null value        \r\n\r\n### Constructors\r\n\r\n    json()\r\nConstructs an empty json object. \r\n\r\n    json(const allocator_type& allocator)\r\nConstructs a json object. \r\n\r\n    json(std::initializer_list<json> list, const allocator_type& allocator)\r\nConstructs a json array with the elements of the initializer-list `init`. \r\n\r\n    json(const json& val)\r\nConstructs a copy of val\r\n\r\n    json(const json& val, const allocator_type& allocator)\r\nCopy with allocator\r\n\r\n    json(json&& val) noexcept\r\nAcquires the contents of val, leaving val a `null` value\r\n\r\n    json(json&& val, const allocator_type& allocator) \r\nMove with allocator\r\n\r\n    template <class T>\r\n    json(const T& val, const allocator_type& allocator=allocator_type())\r\nConstructs a `json` value for types supported in [json_type_traits](json_type_traits).\r\n\r\n    template <class T>\r\n    json(const CharT* val, const allocator_type& allocator=allocator_type())\r\nConstructs a `json` value for string literals.\r\n\r\n    template <class InputIterator>\r\n    json(InputIterator first, InputIterator last, \r\n         const allocator_type& allocator=allocator_type())\r\n\r\nConstructs a json array with the elements in the range [first,last).\r\n\r\n### Destructor\r\n\r\n    ~json()\r\nDestroys all values and deletes all memory allocated for strings, arrays, and objects.\r\n\r\n### Assignment operator\r\n\r\n    json& operator=(const json& rhs)\r\n    json& operator=(json&& rhs) noexcept\r\nAssigns a new `json` value to a `json` variable, replacing it's current contents.\r\n\r\n    template <class T>\r\n    json& operator=(const T& rhs)\r\nAssigns the templated value to a `json` variable using [json_type_traits](json_type_traits).\r\n\r\n    json& operator=(const char_type* rhs)\r\n\r\n### Ranges and Iterators\r\n\r\n    range<object_iterator> object_range();  \r\n    range<const_object_iterator> object_range() const;  \r\nReturns a \"range\" defined by `begin()` and `end()` over the members of a `json` object      \r\nThrows `std::runtime_error` if not an object.\r\n\r\n    range<array_iterator> array_range();\r\n    range<const_array_iterator> array_range() const;\r\nReturns a \"range\" defined by `begin()` and `end()` over the elements of a `json` array      \r\nThrows `std::runtime_error` if not an array.\r\n\r\n### Capacity\r\n\r\n    size_t size() const noexcept\r\nReturns the number of elements in a json array, or the number of members in a json object, or `zero`\r\n\r\n    bool empty() const noexcept\r\nReturns `true` if a json string, object or array has no elements, otherwise `false`.\r\n\r\n    size_t capacity() const\r\nReturns the size of the storage space currently allocated for a json object or array.\r\n\r\n    void reserve(size_t n)\r\nIncreases the capacity of a json object or array to allow at least `n` members or elements. \r\n\r\n    void resize(size_t n)\r\nResizes a json array so that it contains `n` elements. \r\n\r\n    void resize(size_t n, const json& val)\r\nResizes a json array so that it contains `n` elements that are initialized to `val`. \r\n\r\n### Accessors\r\n\r\n    bool has_key(string_view_type name) const\r\nReturns `true` if an object has a member with the given `name`, otherwise `false`.    \r\n\r\n    size_t count(string_view_type name) const\r\nReturns the number of object members that match `name`.    \r\n\r\n    template <class T>\r\n    bool is() const noexcept\r\nReturns `true` if the json value is the same as type `T` according to [json_type_traits](json_type_traits), `false` otherwise.  \r\n\r\n    bool is<X> const noexcept \r\nType `X` is integral: returns `true` if the json value is integral and within the range of the type `X`, `false` otherwise.  \r\nType `X` is floating point: returns `true` if the json value is floating point and within the range of the type `X`, `false` otherwise.  \r\n\r\n    bool is<string_type> const noexcept \r\nReturns `true` if the json value is of string type, `false` otherwise.  \r\n\r\n    bool is<bool> const noexcept \r\nReturns `true` if the json value is of boolean type, `false` otherwise.  \r\n\r\n    bool is<json::null_type> const noexcept\r\nReturns `true` if the json value is null, `false` otherwise.  \r\n\r\n    bool is<json::object> const noexcept \r\nReturns `true` if the json value is an object, `false` otherwise.  \r\n\r\n    bool is<json::array> const noexcept \r\nReturns `true` if the json value is an array, `false` otherwise.  \r\n\r\n    bool is<X<T>> const noexcept\r\nIf the type `X` is not `std::basic_string` but otherwise satisfies [SequenceContainer](http://en.cppreference.com/w/cpp/concept/SequenceContainer), `is<X<T>>()` returns `true` if the json value is an array and each element is the \"same as\" type `T` according to [json_type_traits](json_type_traits), `false` otherwise.\r\n\r\n    bool is<X<string_type,T>> const noexcept\r\nIf the type 'X' satisfies [AssociativeContainer](http://en.cppreference.com/w/cpp/concept/AssociativeContainer) or [UnorderedAssociativeContainer](http://en.cppreference.com/w/cpp/concept/UnorderedAssociativeContainer), `is<X<T>>()` returns `true` if the json value is an object and each mapped value is the \"same as\" `T` according to [json_type_traits](json_type_traits), `false` otherwise.\r\n\r\n    bool is_null() const noexcept\r\n    bool is_string() const noexcept\r\n    bool is_number() const noexcept\r\n    bool is_integer() const noexcept\r\n    bool is_uinteger() const noexcept\r\n    bool is_double() const noexcept\r\n    bool is_bool() const noexcept\r\n    bool is_object() const noexcept\r\n    bool is_array() const noexcept\r\nNon-generic versions of `is_` methods\r\n\r\n    template <class T>\r\n    T as() const\r\nAttempts to convert the json value to the template value type using [json_type_traits](json_type_traits).\r\n\r\n    X as<X>() const\r\nType X is integeral: returns integer value if value is integral, performs cast if value has double type, returns 1 or 0 if value has bool type, attempts conversion if value is string, otherwise throws.\r\nType X is floating point: returns value cast to X if value is integral, returns `NaN` if value is `null`, attempts conversion if value is string, otherwise throws.\r\n\r\n    as<bool>()\r\nReturns `true` if value is `bool` and `true`, or if value is integral and non-zero, or if value is floating point and non-zero, or if value is string and parsed value evaluates as `true`. \r\nReturns `false` if value is `bool` and `false`, or if value is integral and zero, or if value is floating point and zero, or if value is string and parsed value evaluates as `false`. \r\nOtherwise throws `std::runtime_exception`\r\n\r\n    string_type as<string_type>() const noexcept\r\n    string_type as<string_type>(const char_allocator& allocator) const noexcept\r\nIf value is string, returns value, otherwise returns result of `to_string`.\r\n\r\n    as<X<T>>()\r\nIf the type `X` is not `std::basic_string` but otherwise satisfies [SequenceContainer](http://en.cppreference.com/w/cpp/concept/SequenceContainer), `as<X<T>>()` returns the `json` value as an `X<T>` if the `json` value is an array and each element is convertible to type `T`, otherwise throws.\r\n\r\n    as<X<string_type,T>>()\r\nIf the type 'X' satisfies [AssociativeContainer](http://en.cppreference.com/w/cpp/concept/AssociativeContainer) or [UnorderedAssociativeContainer](http://en.cppreference.com/w/cpp/concept/UnorderedAssociativeContainer), `as<X<string_type,T>>()` returns the `json` value as an `X<string_type,T>` if the `json` value is an object and if each member value is convertible to type `T`, otherwise throws.\r\n\r\n    bool as_bool() const\r\n    int64_t as_integer() const\r\n    uint64_t as_uinteger() const\r\n    double as_double() const\r\n    string_view_type as_string_view() const\r\n    string_type as_string() const noexcept\r\n    string_type as_string(const char_allocator& allocator) const noexcept\r\n    unsigned int as<unsigned int> const \r\nNon-generic versions of `as` methods\r\n\r\n    json& operator[](size_t i)\r\n    const json& operator[](size_t i) const\r\nReturns a reference to the value at position i in a json object or array.\r\nThrows `std::runtime_error` if not an object or array.\r\n\r\n    json& operator[](string_view_type name)\r\nReturns a proxy to a keyed value. If written to, inserts or updates with the new value. If read, evaluates to a reference to the keyed value, if it exists, otherwise throws. \r\nThrows `std::runtime_error` if not an object.\r\nIf read, throws `std::out_of_range` if the object does not have a member with the specified name.  \r\n\r\n    const json& operator[](string_view_type name) const\r\nIf `name` matches the name of a member in the json object, returns a reference to the json object, otherwise throws.\r\nThrows `std::runtime_error` if not an object.\r\nThrows `std::out_of_range` if the object does not have a member with the specified name.  \r\n\r\n    object_iterator find(string_view_type name)\r\n    const_object_iterator find(string_view_type name) const\r\nReturns an object iterator to a member whose name compares equal to `name`. If there is no such member, returns `end_member()`.\r\nThrows `std::runtime_error` if not an object.\r\n\r\n    json& at(string_view_type name)\r\n    const json& at(string_view_type name) const\r\nReturns a reference to the value with the specifed name in a json object.\r\nThrows `std::runtime_error` if not an object.\r\nThrows `std::out_of_range` if the object does not have a member with the specified name.  \r\n\r\n    json& at(size_t i)\r\n    const json& at(size_t i) const\r\nReturns a reference to the element at index `i` in a json array.  \r\nThrows `std::runtime_error` if not an array.\r\nThrows `std::out_of_range` if the index is outside the bounds of the array.  \r\n\r\n    template <class T>\r\n    T get_with_default(string_view_type name, \r\n                       const T& default_val) const\r\nIf `name` matches the name of a member in the json object, returns the member value converted to the default's data type, otherwise returns `default_val`.\r\nThrows `std::runtime_error` if not an object.\r\n\r\n    const char_type* get_with_default(string_view_type name, \r\n                                      const char_type* default_val) const\r\nMake `get_with_default` do the right thing for string literals.\r\n\r\n### Modifiers\r\n\r\n    void clear()\r\nRemove all elements from an array or object value, otherwise do nothing\r\n\r\n    void erase(array_iterator first, array_iterator last)\r\nRemove the elements from an array in the range '[first,last)'.\r\nThrows `std::runtime_error` if not an object.\r\n\r\n    void erase(object_iterator first, object_iterator last)\r\nRemove the members from an object in the range '[first,last)'.\r\nThrows `std::runtime_error` if not an object.\r\n\r\n    void erase(string_view_type name)\r\nRemove a member with the specified name from an object\r\nThrows `std::runtime_error` if not an object.\r\n\r\n    void shrink_to_fit()\r\nRequests the removal of unused capacity.\r\n\r\n    template <class T>\r\n    void set(string_view_type name, T&& val)\r\nInserts a new member or replaces an existing member in a json object.\r\nThrows `std::runtime_error` if not an object.\r\n\r\n    template <class T>\r\n    object_iterator set(object_iterator hint, string_view_type name, T&& val)\r\nInserts a new member or replaces an existing member in a json object.\r\nInsertion time is optimized if `hint` points to the member that will precede the inserted member.\r\nReturns a `member_iterator` pointing at the member that was inserted or updated\r\nThrows `std::runtime_error` if not an object.\r\n\r\n    template <class T>\r\n    void add(T&& val)\r\nAdds a new json element at the end of a json array. The argument `val` is forwarded to the `json` constructor as `std::forward<T>(val)`.\r\nThrows `std::runtime_error` if not an array.\r\n\r\n    template <class T>\r\n    array_iterator add(const_array_iterator pos, T&& val)\r\nAdds a new json element at the specified position of a json array, shifting all elements currently at or above that position to the right.\r\nThe argument `val` is forwarded to the `json` constructor as `std::forward<T>(val)`.\r\nReturns an `array_iterator` that points to the new value\r\nThrows `std::runtime_error` if not an array.\r\n\r\n    void swap(json& val)\r\nExchanges the content of the `json` value with the content of `val`, which is another `json` value.\r\n\r\n### Relational operators\r\n\r\n    bool operator==(const json& rhs) const\r\nReturns `true` if two json objects compare equal, `false` otherwise.\r\n\r\n    bool operator!=(const json& rhs) const\r\nReturns `true` if two json objects do not compare equal, `false` otherwise.\r\n\r\n### Serialization\r\n\r\n    string_type to_string(const char_allocator& allocator = char_allocator()) const noexcept\r\nInserts json value into string.\r\n\r\n    string_type to_string(const serialization_options& format, const char_allocator& allocator = char_allocator()) const\r\nInserts json value into string using specified [serialization_options](serialization_options).\r\n\r\n    void write(basic_json_output_handler<char_type>& output_handler) const\r\nCalls `begin_json()` on `output_handler`, emits json value to `output_handler`, and calls `end_json()` on `output_handler`.\r\n\r\n    write write(std::ostream& os) const\r\nInserts json value into stream with default serialization options.\r\n\r\n    write write(std::ostream<CharT> os, const serialization_options& format) const\r\nInserts json value into stream using specified [serialization_options](serialization_options).\r\n\r\n    void write_body(json_output_handler& handler) const\r\nEmits JSON events for JSON objects, arrays, object members and array elements to a [json_output_handler](json_output_handler), such as a [json_serializer](json_serializer).\r\n\r\n### Non member functions\r\n\r\n    std::istream& operator>> (std::istream& os, json& val)\r\nReads a `json` value from a stream.\r\n\r\n    std::ostream& operator<< (std::ostream& os, const json& val)\r\nInserts json value into stream.\r\n\r\n    std::ostream& print(const json& val)  \r\n    std::ostream& print(const json& val, const serialization_options<CharT>& format)  \r\nInserts json value into stream using the specified [serialization_options](serialization_options) if supplied.\r\n\r\n    std::ostream& pretty_print(const json& val)  \r\n    std::ostream& pretty_print(const json& val, const serialization_options<CharT>& format)  \r\nInserts json value into stream using the specified [serialization_options](serialization_options) if supplied.\r\n\r\n    void swap(json& a, json& b)\r\nExchanges the values of `a` and `b`\r\n\r\n### Deprecated names\r\n\r\nAs the `jsoncons` library has evolved, names have sometimes changed. To ease transition, jsoncons deprecates the old names but continues to support many of them. See the [deprecated list](deprecated) for the status of old names. The deprecated names can be suppressed by defining macro JSONCONS_NO_DEPRECATED, which is recommended for new code.\r\n\r\n### See also\r\n\r\n- [ojson](ojson) constructs a json value that preserves the original name-value insertion order\r\n\r\n- [wjson](wjson) constructs a wide character json value that sorts name-value members alphabetically\r\n\r\n- [owjson](owjson) constructs a wide character json value that preserves the original name-value insertion order\r\n\r\n## Examples\r\n\r\n### is and as\r\n```c++\r\n    json j = json::parse(R\"(\r\n    {\r\n        \"k1\" : 2147483647,\r\n        \"k2\" : 2147483648,\r\n        \"k3\" : -10,\r\n        \"k4\" : 10.5,\r\n        \"k5\" : true,\r\n        \"k6\" : \"10.5\"\r\n    }\r\n    )\");\r\n\r\n    std::cout << std::boolalpha << \"(1) \" << j[\"k1\"].is<int32_t>() << '\\n';\r\n    std::cout << std::boolalpha << \"(2) \" << j[\"k2\"].is<int32_t>() << '\\n';\r\n    std::cout << std::boolalpha << \"(3) \" << j[\"k2\"].is<long long>() << '\\n';\r\n    std::cout << std::boolalpha << \"(4) \" << j[\"k3\"].is<signed char>() << '\\n';\r\n    std::cout << std::boolalpha << \"(5) \" << j[\"k3\"].is<uint32_t>() << '\\n';\r\n    std::cout << std::boolalpha << \"(6) \" << j[\"k4\"].is<int32_t>() << '\\n';\r\n    std::cout << std::boolalpha << \"(7) \" << j[\"k4\"].is<double>() << '\\n';\r\n    std::cout << std::boolalpha << \"(8) \" << j[\"k5\"].is<int>() << '\\n';\r\n    std::cout << std::boolalpha << \"(9) \" << j[\"k5\"].is<bool>() << '\\n';\r\n    std::cout << std::boolalpha << \"(10) \" << j[\"k6\"].is<double>() << '\\n';\r\n    std::cout << '\\n';\r\n    std::cout << \"(1) \" << j[\"k1\"].as<int32_t>() << '\\n';\r\n    std::cout << \"(2) \" << j[\"k2\"].as<int32_t>() << '\\n';\r\n    std::cout << \"(3) \" << j[\"k2\"].as<long long>() << '\\n';\r\n    std::cout << \"(4) \" << j[\"k3\"].as<signed char>() << '\\n';\r\n    std::cout << \"(5) \" << j[\"k3\"].as<uint32_t>() << '\\n';\r\n    std::cout << \"(6) \" << j[\"k4\"].as<int32_t>() << '\\n';\r\n    std::cout << \"(7) \" << j[\"k4\"].as<double>() << '\\n';\r\n    std::cout << std::boolalpha << \"(8) \" << j[\"k5\"].as<int>() << '\\n';\r\n    std::cout << std::boolalpha << \"(9) \" << j[\"k5\"].as<bool>() << '\\n';\r\n    std::cout << \"(10) \" << j[\"k6\"].as<double>() << '\\n';\r\n```\r\nOutput:\r\n```\r\n(1) true\r\n(2) false\r\n(3) true\r\n(4) true\r\n(5) false\r\n(6) false\r\n(7) true\r\n(8) false\r\n(9) true\r\n(10) false\r\n\r\n(1) 2147483647\r\n(2) -2147483648\r\n(3) 2147483648\r\n(4) รท\r\n(5) 4294967286\r\n(6) 10\r\n(7) 10.5\r\n(8) 1\r\n(9) true\r\n(10) 10.5\r\n```\r\n\r\n### Range-based for loop over members of an object\r\n```c++\r\njson book = json::parse(R\"(\r\n{\r\n    \"category\" : \"Fiction\",\r\n    \"title\" : \"Pulp\",\r\n    \"author\" : \"Charles Bukowski\",\r\n    \"date\" : \"2004-07-08\",\r\n    \"price\" : 22.48,\r\n    \"isbn\" : \"1852272007\"  \r\n}\r\n)\");\r\n\r\nfor (const auto& kvp: book.object_range())\r\n{\r\n    std::cout << kvp.key() << \":\" << kvp.value().as<string>() << std::endl;\r\n} \r\n```\r\n### Range-based for loop over elements of an array\r\n```c++\r\njson book1;    \r\nbook1[\"category\"] = \"Fiction\";\r\nbook1[\"title\"] = \"A Wild Sheep Chase: A Novel\";\r\nbook1[\"author\"] = \"Haruki Murakami\";\r\n\r\njson book2;    \r\nbook2[\"category\"] = \"History\";\r\nbook2[\"title\"] = \"Charlie Wilson's War\";\r\nbook2[\"author\"] = \"George Crile\";\r\n\r\njson book3;    \r\nbook3[\"category\"] = \"Fiction\";\r\nbook3[\"title\"] = \"Kafka on the Shore\";\r\nbook3[\"author\"] = \"Haruki Murakami\";\r\n\r\n// Constructing a json array with an initializer-list \r\njson booklist = json::array{book1, book2, book3};    \r\n\r\nfor (const auto& book: booklist.array_range())\r\n{\r\n    std::cout << book[\"title\"].as<string_type>() << std::end;\r\n} \r\n   \r\n### Accessors and defaults\r\n```c++\r\njson val;\r\n\r\nval[\"field1\"] = 1;\r\nval[\"field3\"] = \"Toronto\";\r\n\r\ndouble x1 = obj.has_key(\"field1\") ? val[\"field1\"].as<double>() : 10.0;\r\ndouble x2 = obj.has_key(\"field2\") ? val[\"field2\"].as<double>() : 20.0;\r\n\r\nstd::string x3 = obj.get_with_default(\"field3\",\"Montreal\");\r\nstd::string x4 = obj.get_with_default(\"field4\",\"San Francisco\");\r\n\r\nstd::cout << \"x1=\" << x1 << '\\n';\r\nstd::cout << \"x2=\" << x2 << '\\n';\r\nstd::cout << \"x3=\" << x3 << '\\n';\r\nstd::cout << \"x4=\" << x4 << '\\n';\r\n```\r\nOutput:\r\n```c++\r\nx1=1\r\nx2=20\r\nx3=Toronto\r\nx4=San Francisco\r\n```\r\n### Nulls\r\n```c++\r\njson obj;\r\nobj[\"field1\"] = json::null();\r\nstd::cout << obj << std::endl;\r\n```\r\nOutput: \r\n```json\r\n{\"field1\":null}\r\n```\r\n### Array\r\n```c++\r\njson arr = json::array();\r\narr.add(10);\r\narr.add(20);\r\narr.add(30);\r\n\r\nstd::cout << arr << std::endl;\r\n```\r\nOutput: \r\n```json\r\n[10,20,30]\r\n```\r\n### Array from std::vector\r\n```c++\r\nstd::vector<int> v;\r\nv.push_back(10);\r\nv.push_back(20);\r\nv.push_back(30);\r\n\r\njson arr(v.begin(),v.end());\r\n\r\nstd::cout << arr << std::endl;\r\n```\r\nOutput: \r\n```c++\r\n[10,20,30]\r\n```\r\n### Object iterator\r\n```c++\r\njson obj;\r\nobj[\"city\"] = \"Toronto\";\r\nobj[\"province\"] = \"Ontario\";\r\nobj[\"country\"] = \"Canada\";\r\n\r\nfor (auto it = obj.object_range().begin(); it != obj.object_range().end(); ++it)\r\n{\r\n    std::cout << it->key() << \"=\" << it->value().as<string_type>() << std::endl;\r\n}\r\n```\r\nOutput:\r\n```c++\r\ncity=Toronto\r\ncountry=Canada\r\nprovince=Ontario\r\n```\r\n### Array iterator\r\n```c++\r\njson arr = json::array{\"Toronto\", \"Vancouver\", \"Montreal\"};\r\n\r\nfor (auto it = arr.array_range().begin(); it != arr.array_range().end(); ++it)\r\n{\r\n    std::cout << it->as<string_type>() << std::endl;\r\n}\r\n```\r\nOutput:\r\n```json\r\nToronto\r\nVancouver \r\nMontreal\r\n```\r\n### Constructing json structures\r\n```c++\r\njson root;\r\n\r\nroot[\"persons\"] = json::array();\r\n\r\njson person;\r\nperson[\"first_name\"] = \"John\";\r\nperson[\"last_name\"] = \"Smith\";\r\nperson[\"birth_date\"] = \"1972-01-30\";\r\n\r\njson address;\r\naddress[\"city\"] = \"Toronto\";\r\naddress[\"country\"] = \"Canada\";\r\n\r\nperson[\"address\"] = std::move(address);\r\n\r\nroot[\"persons\"].add(std::move(person));\r\n\r\nstd::cout << pretty_print(root) << std::endl;\r\n```\r\nOutput:\r\n```c++\r\n{\r\n    \"persons\":\r\n    [\r\n        {\r\n            \"address\":\r\n            {\r\n                \"city\":\"Toronto\",\r\n                \"country\":\"Canada\"\r\n            },\r\n            \"birth_date\":\"1972-01-30\",\r\n            \"first_name\":\"John\",\r\n            \"last_name\":\"Smith\"\r\n        }\r\n    ]\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}